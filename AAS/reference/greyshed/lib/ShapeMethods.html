<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_121) on Tue Apr 24 14:44:40 EDT 2018 -->
<title>ShapeMethods (Javadocs: AAS)</title>
<meta name="date" content="2018-04-24">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="ShapeMethods (Javadocs: AAS)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":42,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../greyshed/lib/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../greyshed/lib/RotatingCalipers.html" title="class in greyshed.lib"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../index.html?greyshed/lib/ShapeMethods.html" target="_top">Frames</a></li>
<li><a href="ShapeMethods.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">greyshed.lib</div>
<h2 title="Class ShapeMethods" class="title">Class ShapeMethods</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>greyshed.lib.ShapeMethods</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">ShapeMethods</span>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#VERSION">VERSION</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#ShapeMethods-processing.core.PApplet-">ShapeMethods</a></span>(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PApplet.html?is-external=true" title="class or interface in processing.core">PApplet</a>&nbsp;theParent)</code>
<div class="block">a Constructor, usually called in the setup() method in your sketch to
 initialize and start the Library.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#arrayListIntersection-java.util.ArrayList-java.util.ArrayList-">arrayListIntersection</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;a,
                     java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;b)</code>
<div class="block">Check for intersection between two 2D shapes stored as arraylists of PVectors by converting them to generalpath shapes first.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#densifyPolyline-java.util.ArrayList-int-">densifyPolyline</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;crv,
               int&nbsp;goalVtxCount)</code>
<div class="block">Increase the vertices of a polyline to match a desired number of vertices.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#drawPolylineShape-java.util.ArrayList-">drawPolylineShape</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;polylineShape)</code>
<div class="block">Draws an arraylist of PVectors as a polyline using processing's beginShape/vertex/endshape sequence.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#drawPolylineShape-java.util.ArrayList-boolean-">drawPolylineShape</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;polylineShape,
                 boolean&nbsp;close)</code>
<div class="block">Draws an arraylist of PVectors as a polyline using processing's beginShape/vertex/endshape sequence.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#get2DPolygonArea-java.util.ArrayList-">get2DPolygonArea</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vertices)</code>
<div class="block">Get The area of a 2D (X-Y Plane) vertex-defined polygon.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getAverageDist-java.util.ArrayList-java.util.ArrayList-">getAverageDist</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;blobVtc,
              java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;pathVtc)</code>
<div class="block">Get average distance between a blob (or point cluster) and a path or point list.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getAverageDist-java.util.ArrayList-java.util.ArrayList-int-">getAverageDist</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;blobVtc,
              java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;pathVtc,
              int&nbsp;skip)</code>
<div class="block">Get average distance between a blob (or point cluster) and a path or point list.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getBlobColor-java.util.ArrayList-processing.core.PImage-">getBlobColor</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;shape,
            <a href="http://processing.github.io/processing-javadocs/core/processing/core/PImage.html?is-external=true" title="class or interface in processing.core">PImage</a>&nbsp;theImg)</code>
<div class="block">Gets the average color of the pixels inside of a blob (argb)</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getBlobs-processing.core.PImage-">getBlobs</a></span>(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PImage.html?is-external=true" title="class or interface in processing.core">PImage</a>&nbsp;theImg)</code>
<div class="block">Get the blobs in an image as an arraylist of PVectors in the image pixel coordinate space.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getBlobs-processing.core.PImage-float-">getBlobs</a></span>(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PImage.html?is-external=true" title="class or interface in processing.core">PImage</a>&nbsp;theImg,
        float&nbsp;theThreshold)</code>
<div class="block">Get the blobs in an image as an arraylist of PVectors in the image pixel coordinate space.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getConvexHull-java.util.ArrayList-">getConvexHull</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;theClusterToHull)</code>
<div class="block">Return the convex hull (as an arraylist of PVectors) of a polyline or point cloud defined as an arraylist of PVectors
 This function works with 2D PVectors, in the XY plane and currently would strip the z data if given a 3D vector
 Requires <a href="http://leebyron.com/mesh/">Lee Byron's mesh library</a></div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getCorners-java.util.ArrayList-">getCorners</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</code>
<div class="block">Returns the four corner points of the Axis-Aligned (world) bounding box given an arraylist of points</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getCurveIntersection-java.util.ArrayList-float-int-">getCurveIntersection</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;thePathCurve,
                    float&nbsp;theRadius,
                    int&nbsp;theStartIndex)</code>
<div class="block">Finds the point  (not necessarily a vertex) on a polyline that is the given radius away from the vertex at a specified index
Generally useful for, say, placing a series of fixed length objects along an irregular goal path (bricks, glass, straws, etc)
Currently just returns a null vector if no intersection is found.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>float[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getDim-java.util.ArrayList-">getDim</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</code>
<div class="block">Returns the width and height of the world <a href="https://en.wikipedia.org/wiki/Bounding_volume">Axis-Aligned bounding box</a></div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getExtremeIndex-java.util.ArrayList-">getExtremeIndex</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</code>
<div class="block">Returns four indices of points from a list of points:  the point with the smallest X, the largest X, the smallest Y, and the largest Y, in that order</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getFarPoints-java.util.ArrayList-">getFarPoints</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;contourArray)</code>
<div class="block">Given a polyline (arraylist of PVectors), return the two vertices that are farthest from one another as the crow flies (2D or 3D)</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getMinimumBoundingRectangle-java.util.ArrayList-">getMinimumBoundingRectangle</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;theConvexHull)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;&nbsp;</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getMinMax2D-java.util.ArrayList-">getMinMax2D</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</code>
<div class="block">Returns four points from a list of points:  the point with the smallest X, the largest X, the smallest Y, and the largest Y, in that order</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getNextPathIndex-java.util.ArrayList-float-int-">getNextPathIndex</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;thePathCurve,
                float&nbsp;theRadius,
                int&nbsp;theStartIndex)</code>
<div class="block">Finds the next index in a sequence of points that is the given radius away from the starting point
this doesn't work particularly well with high curvature.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getOOBB-java.util.ArrayList-">getOOBB</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;convexHull)</code>
<div class="block">Given a convex hull, return the minimum, object oriented bounding rectangle.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getPolygonCentroid-java.util.ArrayList-">getPolygonCentroid</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vertices)</code>
<div class="block">Get The Centroid of a 2D (X-Y Plane) Vertex-Defined Polygon.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getPolylineShapeLength-java.util.ArrayList-">getPolylineShapeLength</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;polylineShape)</code>
<div class="block">Get the measured length (sum of distance between vertices) of a polyline defined as an arraylist of PVectors</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getSortedIndices-processing.data.FloatList-">getSortedIndices</a></span>(<a href="http://processing.github.io/processing-javadocs/core/processing/data/FloatList.html?is-external=true" title="class or interface in processing.data">FloatList</a>&nbsp;theSizes)</code>
<div class="block">Given a FloatList (a bunch of floats), return an array which represents their indices sorted from smallest to largest.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#getWirePoints-java.util.ArrayList-">getWirePoints</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;contourArray)</code>
<div class="block">given an arraylist of vertices defining the perimeter of a 2D wire/straw-like (bent elongated rectangle) shape,
return a list of points which contains the following items at each index:
[0] the "center" or the midpoint between [1]+[2],
[1]+[2] the two vertices which are closest to one another as the crow flies, but equally spaced from one another along the perimeter of shape
[3]+[4] the approximate end points, or rather, the points that are farthes from one another as the crow flies, but equally spaced from one another along the perimeter of shape</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>java.awt.geom.GeneralPath</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#gpFromArrayList-java.util.ArrayList-">gpFromArrayList</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;pathVtc)</code>
<div class="block">Given a 2D (X-Y plane) arraylist of points representing a polyline shape, return a java generalpath version of that shape</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#offsetPolylineFromPoint-java.util.ArrayList-processing.core.PVector-float-">offsetPolylineFromPoint</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
                       <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;center,
                       float&nbsp;dist)</code>
<div class="block">given an arraylist of vertices defining a shape, shift each vertex away from the center point by the amount specified in "dist"
this is not a true, robust "offset", as different angles will produce different edge offsets and potential intersections
But, if we just need something to approximate a bigger surface to avoid collisions, this will work in a pinch.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#pathIntersection-java.awt.geom.GeneralPath-java.awt.geom.GeneralPath-">pathIntersection</a></span>(java.awt.geom.GeneralPath&nbsp;a,
                java.awt.geom.GeneralPath&nbsp;b)</code>
<div class="block">Perform boolean intersection between two "generalpath" shapes.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#radialIntersection-processing.core.PVector-processing.core.PVector-processing.core.PVector-float-">radialIntersection</a></span>(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;a,
                  <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;b,
                  <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;centerPoint,
                  float&nbsp;rad)</code>
<div class="block">Function for determining the intersection of a line segment and a circle
a = point of line origin within circle, b= point of line outside the circle
centerPoint = centerpoint of the circle, rad = radius of the circle</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#recursiveClustering-java.util.ArrayList-java.util.ArrayList-float-float-">recursiveClustering</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;unClusteredPoints,
                   java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;theClusterMatrix,
                   float&nbsp;maxClstrDist,
                   float&nbsp;minClstrSize)</code>
<div class="block">Given a point cloud in 2D or 3D made of PVectors, cluster the points into groupings based on a given radius
 Points that are within a minimum distance of their neighbors are grouped together with them.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#recursiveSimplify-java.util.ArrayList-processing.core.PVector-java.util.ArrayList-float-">recursiveSimplify</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;crv,
                 <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;nextPoint,
                 java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;simpleCrv,
                 float&nbsp;searchRadius)</code>
<div class="block">This function is intended to return a simplified, "single wall" polyline from a possibly messy, double walled curve
It needs the original curve points, an array that is empty at the start, the starting point, and the radius to simplifiy with
The radius should be smaller than the thickness of the double-walled curve</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#rotatePath-java.util.ArrayList-processing.core.PVector-float-">rotatePath</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
          <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;center,
          float&nbsp;radianAngle)</code>
<div class="block">Rotates a path (or arraylist of points) about a center point by a specified degree angle in radians.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#rotatePoint-processing.core.PVector-processing.core.PVector-float-">rotatePoint</a></span>(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;pt,
           <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;center,
           float&nbsp;radianAngle)</code>
<div class="block">Rotates a point about a center point by a specified degree angle in radians.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#sayHello--">sayHello</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#sortByFloatList-java.util.ArrayList-processing.data.FloatList-">sortByFloatList</a></span>(java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;theBlobs,
               <a href="http://processing.github.io/processing-javadocs/core/processing/data/FloatList.html?is-external=true" title="class or interface in processing.data">FloatList</a>&nbsp;theSizes)</code>
<div class="block">This is a method for sorting an arraylist of blobs (an arraylist of arraylist of vertices)
using a separate key list of floats as a guide.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#splitCurveTwoPts-java.util.ArrayList-int-int-">splitCurveTwoPts</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
                int&nbsp;start,
                int&nbsp;stop)</code>
<div class="block">Splits a polyline into two polylines based on a given start or end index along the curve.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#translatePath-java.util.ArrayList-processing.core.PVector-processing.core.PVector-">translatePath</a></span>(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
             <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;start,
             <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;end)</code>
<div class="block">Moves a path (or any arraylist of points) from one point to another (2D or 3D)</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#translatePoint-processing.core.PVector-processing.core.PVector-processing.core.PVector-">translatePoint</a></span>(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;pt1,
              <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;start,
              <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;end)</code>
<div class="block">Moves a point using a reference point and a target point.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../greyshed/lib/ShapeMethods.html#version--">version</a></span>()</code>
<div class="block">return the version of the Library.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="VERSION">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>VERSION</h4>
<pre>public static final&nbsp;java.lang.String VERSION</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#greyshed.lib.ShapeMethods.VERSION">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="ShapeMethods-processing.core.PApplet-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ShapeMethods</h4>
<pre>public&nbsp;ShapeMethods(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PApplet.html?is-external=true" title="class or interface in processing.core">PApplet</a>&nbsp;theParent)</pre>
<div class="block">a Constructor, usually called in the setup() method in your sketch to
 initialize and start the Library.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theParent</code> - Processing PApplet ("this")</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>import greyshed.lib.*; //import the library

ShapeMethods sm;

PVector pt = new PVector(20,20);
PVector center;

void setup() {
  size(200,200);
  sm = new ShapeMethods(this);
  center = new PVector(width/2,height/2);
}

void draw() {
  background(0);
  PVector rotatedPt = sm.rotatePoint(pt, center, PI);
  strokeWeight(10);
  stroke(255,0,0);
  point(rotatedPt.x,rotatedPt.y);
}
</pre></dd></dl></div></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="sayHello--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sayHello</h4>
<pre>public&nbsp;java.lang.String&nbsp;sayHello()</pre>
</li>
</ul>
<a name="version--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>version</h4>
<pre>public static&nbsp;java.lang.String&nbsp;version()</pre>
<div class="block">return the version of the Library.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>String</dd>
</dl>
</li>
</ul>
<a name="getBlobs-processing.core.PImage-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlobs</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;getBlobs(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PImage.html?is-external=true" title="class or interface in processing.core">PImage</a>&nbsp;theImg)</pre>
<div class="block">Get the blobs in an image as an arraylist of PVectors in the image pixel coordinate space.  
 Requires the <a href="http://www.v3ga.net/processing/BlobDetection/">blobdetection library</a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theImg</code> - the image to search for blobs in</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a two dimensional ArrayList of PVectors describing the found blobs in the image pixel coordinate system</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>/*
Opens an image containing blobs and saves the outlines of the blobs 
to an arraylist made of arraylists of PVectors.  Draws the found outlines in red.

Install the blob detection library (http://www.v3ga.net/processing/BlobDetection/)
 and lee byron's mesh library (http://leebyron.com/mesh/)
 */
import greyshed.lib.*; //import the library
import megamu.mesh.*; //import mesh library
import blobDetection.*; //import blob detection library

PImage img; //this is the image we'll find blobs in
//make an arraylist to store all of our blobs.  Each blob is itself an arraylist of PVectors (the points on the blob)
ArrayList<ArrayList<PVector>> blobMatrix = new ArrayList<ArrayList<PVector>>();
ShapeMethods sm = new ShapeMethods(this);

void setup() {
  size(640, 480); //set our screen size
  img = loadImage("straws.jpg"); //load the picture containing our blobs (or replace with webcam image)
}

void draw() {
  image(img, 0, 0); //draw our image containing blobs to the screen
  //find the blobs in the image using a threshold of .5, and save them to the arraylist "blobMatrix"
  blobMatrix = sm.getBlobs(img, .5); 
  noFill(); //don't fill our drawn shapes
  stroke(255, 0, 0); //set our stroke color to red
  strokeWeight(2); //set our lineweight to 2
  //draw each of our found blobs to the screen
  for (int i = 0; i< blobMatrix.size(); i++) {
    sm.drawPolylineShape(blobMatrix.get(i));
  }
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="getBlobs-processing.core.PImage-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlobs</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;getBlobs(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PImage.html?is-external=true" title="class or interface in processing.core">PImage</a>&nbsp;theImg,
                                                                  float&nbsp;theThreshold)</pre>
<div class="block">Get the blobs in an image as an arraylist of PVectors in the image pixel coordinate space.  Requires the <a href="http://www.v3ga.net/processing/BlobDetection/">blobdetection library</a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theImg</code> - the image to search for blobs in</dd>
<dd><code>theThreshold</code> - the image threshold for blob detection</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a two dimensional ArrayList of PVectors describing the found blobs in the image pixel coordinate system</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>/*
Opens an image containing blobs and saves the outlines of the blobs 
to an arraylist made of arraylists of PVectors.  Draws the found outlines in red.

Install the blob detection library (http://www.v3ga.net/processing/BlobDetection/)
 and lee byron's mesh library (http://leebyron.com/mesh/)
 */
import greyshed.lib.*; //import the library
import megamu.mesh.*; //import mesh library
import blobDetection.*; //import blob detection library

PImage img; //this is the image we'll find blobs in
//make an arraylist to store all of our blobs.  Each blob is itself an arraylist of PVectors (the points on the blob)
ArrayList<ArrayList<PVector>> blobMatrix = new ArrayList<ArrayList<PVector>>();
ShapeMethods sm = new ShapeMethods(this);

void setup() {
  size(640, 480); //set our screen size
  img = loadImage("straws.jpg"); //load the picture containing our blobs (or replace with webcam image)
}

void draw() {
  image(img, 0, 0); //draw our image containing blobs to the screen
  //find the blobs in the image using a threshold of .5, and save them to the arraylist "blobMatrix"
  blobMatrix = sm.getBlobs(img, .5); 
  noFill(); //don't fill our drawn shapes
  stroke(255, 0, 0); //set our stroke color to red
  strokeWeight(2); //set our lineweight to 2
  //draw each of our found blobs to the screen
  for (int i = 0; i< blobMatrix.size(); i++) {
    sm.drawPolylineShape(blobMatrix.get(i));
  }
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="getPolylineShapeLength-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPolylineShapeLength</h4>
<pre>public&nbsp;float&nbsp;getPolylineShapeLength(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;polylineShape)</pre>
<div class="block">Get the measured length (sum of distance between vertices) of a polyline defined as an arraylist of PVectors</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polylineShape</code> - polyline to get the length of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the polyline length</dd>
</dl>
</li>
</ul>
<a name="getFarPoints-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFarPoints</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]&nbsp;getFarPoints(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;contourArray)</pre>
<div class="block">Given a polyline (arraylist of PVectors), return the two vertices that are farthest from one another as the crow flies (2D or 3D)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contourArray</code> - polyline to get the far points of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of two PVectors</dd>
</dl>
</li>
</ul>
<a name="getWirePoints-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWirePoints</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]&nbsp;getWirePoints(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;contourArray)</pre>
<div class="block">given an arraylist of vertices defining the perimeter of a 2D wire/straw-like (bent elongated rectangle) shape,
return a list of points which contains the following items at each index:
[0] the "center" or the midpoint between [1]+[2],
[1]+[2] the two vertices which are closest to one another as the crow flies, but equally spaced from one another along the perimeter of shape
[3]+[4] the approximate end points, or rather, the points that are farthes from one another as the crow flies, but equally spaced from one another along the perimeter of shape
<p>
note that because this function is only looking at vertices, and not at the spaces between vertices, 
it won't be very accurate with polylines that are not very dense (i.e. with long line segments)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contourArray</code> - a 2D polyline as an arrayList of PVectors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of five PVectors where [0] is the "center", or the midpoint between [1]+[2] which are the points near the center on the perimeter, and [3]+[4] which are the "endpoints"</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>/*
Gets relevant points on long, skinny objects found using blob detection.
 */
import greyshed.lib.*; //import the library
import megamu.mesh.*; //import mesh library
import blobDetection.*; //import blob detection library

PImage img; //this is the image we'll find blobs in
//make an arraylist to store all of our blobs.  Each blob is itself an arraylist of PVectors (the points on the blob)
ArrayList<ArrayList<PVector>> blobMatrix = new ArrayList<ArrayList<PVector>>();
ShapeMethods sm = new ShapeMethods(this); //create a new instance of our shapemethods class, which we can call with "sm"

void setup() {
  size(640, 480); //set our screen size
  img = loadImage("straws.jpg"); //load the picture containing our blobs (or replace with webcam image)
}

void draw() {
  image(img, 0, 0); //draw our image containing blobs to the screen
  //find the blobs in the image using a threshold of .5, and save them to the arraylist "blobMatrix"
  blobMatrix = sm.getBlobs(img, .5); 

  //for each found blob...
  for (int i = 0; i< blobMatrix.size(); i++) {
    noFill(); //don't fill our drawn shapes
    stroke(255, 0, 0); //set our stroke color to red
    strokeWeight(2); //set our lineweight to 2
    sm.drawPolylineShape(blobMatrix.get(i)); //draw the blob to the screen
    PVector [] wirePts = sm.getWirePoints(blobMatrix.get(i)); //get the "important points" on this straw and save them to an array
    //now that we have our points, draw them to the screen
    strokeWeight(10); //draw our wire points as a big dot
    stroke(0, 255, 0); //draw the center as green
    point(wirePts[0].x, wirePts[0].y); //draw the found center pt
    stroke(255, 255, 0); //draw the edgepoints near the center as yellow
    point(wirePts[1].x, wirePts[1].y);//draw the found edge pt
    point(wirePts[2].x, wirePts[2].y);//draw the found edge pt
    stroke(0, 0, 255); //draw the end points as blue
    point(wirePts[3].x, wirePts[3].y);//draw the found end pt
    point(wirePts[4].x, wirePts[4].y);//draw the found end pt
    float wireRadius = max(PVector.dist(wirePts[0], wirePts[3]), PVector.dist(wirePts[0], wirePts[4])); //get the radius of the straw
  }
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="getConvexHull-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConvexHull</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;getConvexHull(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;theClusterToHull)</pre>
<div class="block">Return the convex hull (as an arraylist of PVectors) of a polyline or point cloud defined as an arraylist of PVectors
 This function works with 2D PVectors, in the XY plane and currently would strip the z data if given a 3D vector
 Requires <a href="http://leebyron.com/mesh/">Lee Byron's mesh library</a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theClusterToHull</code> - polyline to get the 2D convex hull of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the convex hull as a clockwise-ordered arraylist of PVectors</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>/*
Finds the convex hull of a number of blobs found in an image
 */
import greyshed.lib.*; //import the library
import megamu.mesh.*; //import mesh library
import blobDetection.*; //import blob detection library

PImage img; //this is the image we'll find blobs in
//make an arraylist to store all of our blobs.  Each blob is itself an arraylist of PVectors (the points on the blob)
ArrayList<ArrayList<PVector>> blobMatrix = new ArrayList<ArrayList<PVector>>();
ShapeMethods sm = new ShapeMethods(this); //create a new instance of our shapemethods class, which we can call with "sm"

void setup() {
  size(640, 480); //set our screen size
  img = loadImage("straws.jpg"); //load the picture containing our blobs (or replace with webcam image)
}

void draw() {
  image(img, 0, 0); //draw our image containing blobs to the screen
  //find the blobs in the image using a threshold of .5, and save them to the arraylist "blobMatrix"
  blobMatrix = sm.getBlobs(img, .5); 

  //for each found blob...
  for (int i = 0; i< blobMatrix.size(); i++) {
    noFill(); //don't fill our drawn shapes
    stroke(255, 0, 0); //set our stroke color to red
    strokeWeight(2); //set our lineweight to 2
    sm.drawPolylineShape(blobMatrix.get(i)); //draw the blob to the screen
    ArrayList<PVector> convexHull = sm.getConvexHull(blobMatrix.get(i)); //get the convex hull of the current blob
    stroke(0,255,0); //set our fill color to green
    sm.drawPolylineShape(convexHull); //draw our convex hull in green
    PVector hullCen = sm.getPolygonCentroid(convexHull); //get the centroid of the convex hull
    strokeWeight(10); //make our point big
    point(hullCen.x,hullCen.y); //draw the center point
 }
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="getDim-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDim</h4>
<pre>public&nbsp;float[]&nbsp;getDim(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</pre>
<div class="block">Returns the width and height of the world <a href="https://en.wikipedia.org/wiki/Bounding_volume">Axis-Aligned bounding box</a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - polyline to get the bounding dimensions of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of two floats representing the width and height of the bounding rectangle</dd>
</dl>
</li>
</ul>
<a name="getMinMax2D-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinMax2D</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]&nbsp;getMinMax2D(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</pre>
<div class="block">Returns four points from a list of points:  the point with the smallest X, the largest X, the smallest Y, and the largest Y, in that order</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - polyline to get the far points of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of four PVEctors representing the points with the largest and smallest x and y values</dd>
</dl>
</li>
</ul>
<a name="getExtremeIndex-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExtremeIndex</h4>
<pre>public&nbsp;int[]&nbsp;getExtremeIndex(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</pre>
<div class="block">Returns four indices of points from a list of points:  the point with the smallest X, the largest X, the smallest Y, and the largest Y, in that order</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - polyline to get the far points of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of four ints representing the index of points with the largest and smallest x and y values</dd>
</dl>
</li>
</ul>
<a name="splitCurveTwoPts-java.util.ArrayList-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitCurveTwoPts</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;splitCurveTwoPts(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
                                                                          int&nbsp;start,
                                                                          int&nbsp;stop)</pre>
<div class="block">Splits a polyline into two polylines based on a given start or end index along the curve.  
 Two points are provided, and the direction of each returned polyline will move in the direction from the first index to the second index</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - polyline to split (typically closed)</dd>
<dd><code>start</code> - index to split at</dd>
<dd><code>stop</code> - index to split at</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a an arraylist<arrayList<PVector>> with two elements, each being a polyline</dd>
</dl>
</li>
</ul>
<a name="getMinimumBoundingRectangle-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinimumBoundingRectangle</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]&nbsp;getMinimumBoundingRectangle(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;theConvexHull)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;</div>
<div class="block">Given a convex hull, return the minimum, object oriented bounding rectangle. Found using rotating calipers.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theConvexHull</code> - covnex hull to get minimum bounding rectangle of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of four PVectors representing the four corner points of the bounding rectangle</dd>
</dl>
</li>
</ul>
<a name="getOOBB-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOOBB</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]&nbsp;getOOBB(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;convexHull)</pre>
<div class="block">Given a convex hull, return the minimum, object oriented bounding rectangle. Probably not the most elegant solution.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theConvexHull</code> - covnex hull to get minimum bounding rectangle of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of four PVectors representing the four corner points of the bounding rectangle</dd>
</dl>
</li>
</ul>
<a name="getCorners-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCorners</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>[]&nbsp;getCorners(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc)</pre>
<div class="block">Returns the four corner points of the Axis-Aligned (world) bounding box given an arraylist of points</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - the points to find the boundaries of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a list of four PVectors representing the four corner points of the bounding rectangle</dd>
</dl>
</li>
</ul>
<a name="recursiveClustering-java.util.ArrayList-java.util.ArrayList-float-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recursiveClustering</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;recursiveClustering(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;unClusteredPoints,
                                                                             java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;theClusterMatrix,
                                                                             float&nbsp;maxClstrDist,
                                                                             float&nbsp;minClstrSize)</pre>
<div class="block">Given a point cloud in 2D or 3D made of PVectors, cluster the points into groupings based on a given radius
 Points that are within a minimum distance of their neighbors are grouped together with them.  
 Groups with a count below a give size are not returned.  
 As the unculstered beginning points are deleted as the function runs, input a copy of your unclustered point arraylist.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>unClusteredPoints</code> - an arraylist of PVectors representing a 2D or 3D point cloud</dd>
<dd><code>theClusterMatrix</code> - an empty (at the beginning) ArrayList of Arraylists of PVectors, containing the clustered points</dd>
<dd><code>maxClstrDist</code> - the maximum distance between points where they should be grouped together and considered part of the same cluster</dd>
<dd><code>minClstrSize</code> - the fewest number of points required to be considered a cluster</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a matrix of clustered points, grouped with their neighbors</dd>
</dl>
</li>
</ul>
<a name="translatePoint-processing.core.PVector-processing.core.PVector-processing.core.PVector-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translatePoint</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;translatePoint(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;pt1,
                              <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;start,
                              <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;end)</pre>
<div class="block">Moves a point using a reference point and a target point. (2D or 3D)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pt1</code> - the point to move</dd>
<dd><code>start</code> - the reference point for moving from</dd>
<dd><code>end</code> - the reference point for moving to</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point (p1) moved along the vector defined by end-start</dd>
</dl>
</li>
</ul>
<a name="rotatePoint-processing.core.PVector-processing.core.PVector-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotatePoint</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;rotatePoint(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;pt,
                           <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;center,
                           float&nbsp;radianAngle)</pre>
<div class="block">Rotates a point about a center point by a specified degree angle in radians.  2D rotation in the xy plane.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pt</code> - the point to rotate</dd>
<dd><code>center</code> - the point to rotate about</dd>
<dd><code>radianAngle</code> - the amount to rotate (radians)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the rotated point</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>import greyshed.lib.*; //import the library

ShapeMethods sm;

PVector pt = new PVector(20,20);
PVector center;

void setup() {
  size(200,200);
  sm = new ShapeMethods(this);
  center = new PVector(width/2,height/2);
}

void draw() {
  background(0);
  PVector rotatedPt = sm.rotatePoint(pt, center, PI);
  strokeWeight(10);
  stroke(255,0,0);
  point(rotatedPt.x,rotatedPt.y);
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="translatePath-java.util.ArrayList-processing.core.PVector-processing.core.PVector-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translatePath</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;translatePath(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
                                                  <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;start,
                                                  <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;end)</pre>
<div class="block">Moves a path (or any arraylist of points) from one point to another (2D or 3D)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - the points to move</dd>
<dd><code>start</code> - the reference point for moving from</dd>
<dd><code>end</code> - the reference point for moving to</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the arraylist of points moved along the vector defined by end-start</dd>
</dl>
</li>
</ul>
<a name="rotatePath-java.util.ArrayList-processing.core.PVector-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotatePath</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;rotatePath(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
                                               <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;center,
                                               float&nbsp;radianAngle)</pre>
<div class="block">Rotates a path (or arraylist of points) about a center point by a specified degree angle in radians.  2D rotation in the xy plane.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - the points to rotate</dd>
<dd><code>center</code> - the point to rotate about</dd>
<dd><code>radianAngle</code> - the amount to rotate (radians)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the rotated points</dd>
</dl>
</li>
</ul>
<a name="getAverageDist-java.util.ArrayList-java.util.ArrayList-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAverageDist</h4>
<pre>public&nbsp;float&nbsp;getAverageDist(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;blobVtc,
                            java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;pathVtc,
                            int&nbsp;skip)</pre>
<div class="block">Get average distance between a blob (or point cluster) and a path or point list.  
 For each vertex in the first list, it finds the closest point in the second list.  
 The function returns the average of those distances for each vertex.  
 Good for comparing two shapes or point clouds to see if they are similar, or to see if a blob is placed well on a goal curve. 
         
 <p>
 As this function is pretty brute force, the skip variable allows you to use every nth vertex in the first list for comparison</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>blobVtc</code> - the first set of points to compare</dd>
<dd><code>pathVtc</code> - the second set of points to compare</dd>
<dd><code>skip</code> - an integer for skipping points in the first set to speed up computing.  Minimum value of 1 includes all points.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the average distance</dd>
</dl>
</li>
</ul>
<a name="getAverageDist-java.util.ArrayList-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAverageDist</h4>
<pre>public&nbsp;float&nbsp;getAverageDist(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;blobVtc,
                            java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;pathVtc)</pre>
<div class="block">Get average distance between a blob (or point cluster) and a path or point list.  
 For each vertex in the first list, it finds the closest point in the second list.  
 The function returns the average of those distances for each vertex. 
 Good for comparing two shapes or point clouds to see if they are similar, or to see if a blob is placed well on a goal curve. 
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>blobVtc</code> - the first set of points to compare</dd>
<dd><code>pathVtc</code> - the second set of points to compare</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the average distance</dd>
</dl>
</li>
</ul>
<a name="getPolygonCentroid-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPolygonCentroid</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;getPolygonCentroid(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vertices)</pre>
<div class="block">Get The Centroid of a 2D (X-Y Plane) Vertex-Defined Polygon.  
 From <a href="http://stackoverflow.com/questions/2792443/finding-the-centroid-of-a-polygon">Stack Overflow</a>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - the vertices defining the outline of the shape to find the centroid of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the centroid as a PVector</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>/*
Finds the convex hull of a number of blobs found in an image
 */
import greyshed.lib.*; //import the library
import megamu.mesh.*; //import mesh library
import blobDetection.*; //import blob detection library

PImage img; //this is the image we'll find blobs in
//make an arraylist to store all of our blobs.  Each blob is itself an arraylist of PVectors (the points on the blob)
ArrayList<ArrayList<PVector>> blobMatrix = new ArrayList<ArrayList<PVector>>();
ShapeMethods sm = new ShapeMethods(this); //create a new instance of our shapemethods class, which we can call with "sm"

void setup() {
  size(640, 480); //set our screen size
  img = loadImage("straws.jpg"); //load the picture containing our blobs (or replace with webcam image)
}

void draw() {
  image(img, 0, 0); //draw our image containing blobs to the screen
  //find the blobs in the image using a threshold of .5, and save them to the arraylist "blobMatrix"
  blobMatrix = sm.getBlobs(img, .5); 

  //for each found blob...
  for (int i = 0; i< blobMatrix.size(); i++) {
    noFill(); //don't fill our drawn shapes
    stroke(255, 0, 0); //set our stroke color to red
    strokeWeight(2); //set our lineweight to 2
    sm.drawPolylineShape(blobMatrix.get(i)); //draw the blob to the screen
    ArrayList<PVector> convexHull = sm.getConvexHull(blobMatrix.get(i)); //get the convex hull of the current blob
    stroke(0,255,0); //set our fill color to green
    sm.drawPolylineShape(convexHull); //draw our convex hull in green
    PVector hullCen = sm.getPolygonCentroid(convexHull); //get the centroid of the convex hull
    strokeWeight(10); //make our point big
    point(hullCen.x,hullCen.y); //draw the center point
 }
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="get2DPolygonArea-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get2DPolygonArea</h4>
<pre>public&nbsp;float&nbsp;get2DPolygonArea(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vertices)</pre>
<div class="block">Get The area of a 2D (X-Y Plane) vertex-defined polygon.
 Assumes closed polygon does not have duplicated start/endpoint...but will probably work in either case
 <a href="http://stackoverflow.com/questions/2792443/finding-the-centroid-of-a-polygon">Stack Overflow</a>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertices</code> - the vertices defining the outline of the 2D shape to find the area of</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the 2D area</dd>
</dl>
</li>
</ul>
<a name="gpFromArrayList-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gpFromArrayList</h4>
<pre>public&nbsp;java.awt.geom.GeneralPath&nbsp;gpFromArrayList(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;pathVtc)</pre>
<div class="block">Given a 2D (X-Y plane) arraylist of points representing a polyline shape, return a java generalpath version of that shape</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pathVtc</code> - the vertices defining the outline of the 2D shape</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the converted generalpath</dd>
</dl>
</li>
</ul>
<a name="pathIntersection-java.awt.geom.GeneralPath-java.awt.geom.GeneralPath-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pathIntersection</h4>
<pre>public&nbsp;boolean&nbsp;pathIntersection(java.awt.geom.GeneralPath&nbsp;a,
                                java.awt.geom.GeneralPath&nbsp;b)</pre>
<div class="block">Perform boolean intersection between two "generalpath" shapes.
Using java's area method, check for intersection between two paths.
Note that the path needs to be closed, and built using the correct winding rule.
That is most likely the problem if this doesn't work...</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - the first shape to check for intersection</dd>
<dd><code>b</code> - the second shape to check for intersection</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true for intersection, false for no intersection</dd>
</dl>
</li>
</ul>
<a name="arrayListIntersection-java.util.ArrayList-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arrayListIntersection</h4>
<pre>public&nbsp;boolean&nbsp;arrayListIntersection(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;a,
                                     java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;b)</pre>
<div class="block">Check for intersection between two 2D shapes stored as arraylists of PVectors by converting them to generalpath shapes first.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - the first shape to check for intersection</dd>
<dd><code>b</code> - the second shape to check for intersection</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true for intersection, false for no intersection</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../greyshed/lib/ShapeMethods.html#pathIntersection-java.awt.geom.GeneralPath-java.awt.geom.GeneralPath-"><code>pathIntersection(GeneralPath, GeneralPath)</code></a></dd>
</dl>
</li>
</ul>
<a name="offsetPolylineFromPoint-java.util.ArrayList-processing.core.PVector-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>offsetPolylineFromPoint</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;offsetPolylineFromPoint(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;vtc,
                                                            <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;center,
                                                            float&nbsp;dist)</pre>
<div class="block">given an arraylist of vertices defining a shape, shift each vertex away from the center point by the amount specified in "dist"
this is not a true, robust "offset", as different angles will produce different edge offsets and potential intersections
But, if we just need something to approximate a bigger surface to avoid collisions, this will work in a pinch.
Using the convex hull of the shape instead of the shape is going to be safest.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vtc</code> - the first shape to check for intersection</dd>
<dd><code>center</code> - the point to offset away from.</dd>
<dd><code>dist</code> - the distance to offset the points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the offset vertex arraylist</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../greyshed/lib/ShapeMethods.html#getPolygonCentroid-java.util.ArrayList-"><code>getPolygonCentroid(ArrayList)</code></a>, 
<a href="../../greyshed/lib/ShapeMethods.html#getConvexHull-java.util.ArrayList-"><code>getConvexHull(ArrayList)</code></a></dd>
</dl>
</li>
</ul>
<a name="sortByFloatList-java.util.ArrayList-processing.data.FloatList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sortByFloatList</h4>
<pre>public&nbsp;java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;sortByFloatList(java.util.ArrayList&lt;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&gt;&nbsp;theBlobs,
                                                                         <a href="http://processing.github.io/processing-javadocs/core/processing/data/FloatList.html?is-external=true" title="class or interface in processing.data">FloatList</a>&nbsp;theSizes)</pre>
<div class="block">This is a method for sorting an arraylist of blobs (an arraylist of arraylist of vertices)
using a separate key list of floats as a guide.
In example, given an arraylist of blobs, and a matching 1d arraylist (FloatList) of blob areas,
return a arraylist of blobs sorted from smallest to biggest</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theBlobs</code> - the blobs to sort</dd>
<dd><code>theSizes</code> - a floatlist to use as a key for sorting the first list of Vertex-defined shapes.  Should match the first list in size.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the sorted list of polylines</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>/*
Generate random clusters of points, find their convex hull and then sort them based on area
 */
import greyshed.lib.*; //import the library
import megamu.mesh.*; //import mesh library

//make an arraylist to store our randomly generated point clusters
ArrayList<ArrayList<PVector>> pointMatrix = new ArrayList<ArrayList<PVector>>();
//make an arraylist to store the convex hull outlines of each generated point cluster
ArrayList<ArrayList<PVector>> hullMatrix = new ArrayList<ArrayList<PVector>>();
FloatList hullAreas = new FloatList(); //create a float list to store the area of each shape
ShapeMethods sm = new ShapeMethods(this); //create a new instance of our shapemethods class, which we can call with "sm"

int numClusters = 40; //how many point cluster objects should we generate?
int numPointsPerCluster = 6; //set the number of points in our cluster.  More would mean less variability in shapes...
float clusterWidth = 50; //set the possible width of our cluster
float clusterHeight = 100; //set the possible height of our cluster

void setup() {
  size(1200, 600); //set our screen size
  for (int i = 0; i< numClusters; i++) { //for each desired cluster
    ArrayList<PVector> thePoints = new ArrayList<PVector>(); //an arraylist to store the points in this cluster
    for (int j = 0; j< numPointsPerCluster; j++) { //for each desired point
      PVector randomPoint = new PVector(random(0, clusterWidth), random(0, clusterHeight)); //generate a random point
      thePoints.add(randomPoint); //add our random point to our list for this cluster
    }//end for each point
    pointMatrix.add(thePoints); //add our points to the matrix of points
    ArrayList<PVector> theCVHull = sm.getConvexHull(thePoints); //get the convex hull of our cluster
    hullMatrix.add(theCVHull); //add our convex hull to the parallel list that stores that.
  }//end for each cluster
}

void draw() {

  //for each cluster of points/blob...
  for (int i = 0; i< pointMatrix.size(); i++) {
    PVector hullCen = sm.getPolygonCentroid(hullMatrix.get(i)); //get the centroid of the current convex hull
    PVector pointToDrawAt = new PVector((1+i%20)*clusterWidth, (1+round(i/20))*clusterHeight);
    //move the path from the shape center point to an even grid so they don't draw all on top of one another
    ArrayList<PVector> translatedHull = sm.translatePath(hullMatrix.get(i), hullCen, pointToDrawAt); 
    noFill(); //don't fill our drawn shapes
    stroke(255, 0, 0); //set our stroke color to red
    strokeWeight(2); //set our lineweight to 2
    sm.drawPolylineShape(translatedHull, true); //draw the blob to the screen and close it
    strokeWeight(10); //make our point big
    point(pointToDrawAt.x, pointToDrawAt.y); //draw the center point of the shape, which should be on our grid

    float hullArea = sm.get2DPolygonArea(hullMatrix.get(i)); //get the area of our shape
    hullAreas.append(hullArea); //add the area to our list of areas so we can use it later for sorting
  } //end first for loop

  //make a new arraylist of our shapes that is the same shapes sorted by our reference floatlist of areas
  ArrayList<ArrayList<PVector>> sortedHulls = sm.sortByFloatList(hullMatrix, hullAreas); 
  //now, let's draw all the shapes again at the bottom half of the screen, but sorted this time by area
  for (int i = 0; i< sortedHulls.size(); i++) { //for each shape
    PVector hullCen = sm.getPolygonCentroid(sortedHulls.get(i)); //get the centroid of the current convex hull
    PVector pointToDrawAt = new PVector((1+i%20)*clusterWidth, (height/2)+(1+round(i/20))*clusterHeight); //draw it in a grid in the lower half of the screen
    //move the path from the shape center point to an even grid so they don't draw all on top of one another
    ArrayList<PVector> translatedHull = sm.translatePath(sortedHulls.get(i), hullCen, pointToDrawAt); 
    noFill(); //don't fill our drawn shapes
    stroke(0, 0, 255); //set our stroke color to blue
    strokeWeight(2); //set our lineweight to 2
    sm.drawPolylineShape(translatedHull, true); //draw the blob to the screen and close it
  }
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="getSortedIndices-processing.data.FloatList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSortedIndices</h4>
<pre>public&nbsp;int[]&nbsp;getSortedIndices(<a href="http://processing.github.io/processing-javadocs/core/processing/data/FloatList.html?is-external=true" title="class or interface in processing.data">FloatList</a>&nbsp;theSizes)</pre>
<div class="block">Given a FloatList (a bunch of floats), return an array which represents their indices sorted from smallest to largest.
This is useful for using it to sort through an object of a random type, which you can just fill a new list using the order returned from this function.
You should probably just use a TreeMap for this, but this provides a quick method if you are extra extra lazy.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>theSizes</code> - a FloatList containing values by which you want to sort another list of objects</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array containing the sorted indices
        //</dd>
</dl>
</li>
</ul>
<a name="getNextPathIndex-java.util.ArrayList-float-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextPathIndex</h4>
<pre>public&nbsp;int&nbsp;getNextPathIndex(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;thePathCurve,
                            float&nbsp;theRadius,
                            int&nbsp;theStartIndex)</pre>
<div class="block">Finds the next index in a sequence of points that is the given radius away from the starting point
this doesn't work particularly well with high curvature.  Could try taking cumulative length of segments instead...
it is also poorly named/documented.  Basically, given a start point, find the next index that is outside the given radius
moving in order of the vertices as ordered in the arraylist
Generally useful for, say, placing a series of fixed length objects along an irregular goal path (bricks, glass, straws, etc)
Currently just returns 0 if no index is found.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thePathCurve</code> - the polyline to look for indices along</dd>
<dd><code>theRadius</code> - the search radius</dd>
<dd><code>theStartIndex</code> - the index from which we should start the serch</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an integer that represents the first index that is "theRadius" or more away from the point at the startIndex</dd>
</dl>
</li>
</ul>
<a name="getCurveIntersection-java.util.ArrayList-float-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCurveIntersection</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;getCurveIntersection(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;thePathCurve,
                                    float&nbsp;theRadius,
                                    int&nbsp;theStartIndex)</pre>
<div class="block">Finds the point  (not necessarily a vertex) on a polyline that is the given radius away from the vertex at a specified index
Generally useful for, say, placing a series of fixed length objects along an irregular goal path (bricks, glass, straws, etc)
Currently just returns a null vector if no intersection is found.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>thePathCurve</code> - the polyline to look for indices along</dd>
<dd><code>theRadius</code> - the search radius</dd>
<dd><code>theStartIndex</code> - the index from which we should start the serch</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a PVector that represents the point on the polyline that is "theRadius" away from the point at the startIndex</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../greyshed/lib/ShapeMethods.html#getNextPathIndex-java.util.ArrayList-float-int-"><code>getNextPathIndex(ArrayList, float, int)</code></a></dd>
</dl>
</li>
</ul>
<a name="radialIntersection-processing.core.PVector-processing.core.PVector-processing.core.PVector-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>radialIntersection</h4>
<pre>public&nbsp;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;radialIntersection(<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;a,
                                  <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;b,
                                  <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;centerPoint,
                                  float&nbsp;rad)</pre>
<div class="block">Function for determining the intersection of a line segment and a circle
a = point of line origin within circle, b= point of line outside the circle
centerPoint = centerpoint of the circle, rad = radius of the circle</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - the start point of the line segment</dd>
<dd><code>b</code> - the end point of the line segment</dd>
<dd><code>centerPoint</code> - the center point of the circle</dd>
<dd><code>rad</code> - the radius of the circle</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point where a circle intersects a line segment.  Null if no intersection.</dd>
</dl>
</li>
</ul>
<a name="recursiveSimplify-java.util.ArrayList-processing.core.PVector-java.util.ArrayList-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recursiveSimplify</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;recursiveSimplify(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;crv,
                                                      <a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&nbsp;nextPoint,
                                                      java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;simpleCrv,
                                                      float&nbsp;searchRadius)</pre>
<div class="block">This function is intended to return a simplified, "single wall" polyline from a possibly messy, double walled curve
It needs the original curve points, an array that is empty at the start, the starting point, and the radius to simplifiy with
The radius should be smaller than the thickness of the double-walled curve
<p>
Essentially, it starts at a given point, and searches within a designated radius, deleting all points within that radius except for the one that is farthest away.
It adds that point to the list of points to return, and does the function again starting at that vertex until there are no more vertices remaining within the search radius.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>crv</code> - the arraylist of points defining a shape to simplify</dd>
<dd><code>nextPoint</code> - the point to start simplifying from.  This should be at an extreme of the shape, as once the function starts it only moves in one direction</dd>
<dd><code>simpleCrv</code> - the simplified curve to return.  Should be empty at the start of the function</dd>
<dd><code>searchRadius</code> - the radius to simplify by.  Should be larger than the width of a double-walled tube if wanting to turn it into a single walled line.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the simplified polyline as an arraylist of PVectors</dd>
</dl>
</li>
</ul>
<a name="densifyPolyline-java.util.ArrayList-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>densifyPolyline</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;densifyPolyline(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;crv,
                                                    int&nbsp;goalVtxCount)</pre>
<div class="block">Increase the vertices of a polyline to match a desired number of vertices.
<p>
This is a very brutish and terribly written function for increasing the density of a polyline.
Basically, it adds vertices to segments that are longer than the average desired distance as even subdivisions between existing vertices...
Needs reworking, but written quickly for use in a pinch...</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>crv</code> - the arraylist of points defining a shape to set the density of</dd>
<dd><code>goalVtxCount</code> - the desired number of vertices on this polyline</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the polyline with the (approximately?) desired number of vertices</dd>
</dl>
</li>
</ul>
<a name="getBlobColor-java.util.ArrayList-processing.core.PImage-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlobColor</h4>
<pre>public&nbsp;int&nbsp;getBlobColor(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;shape,
                        <a href="http://processing.github.io/processing-javadocs/core/processing/core/PImage.html?is-external=true" title="class or interface in processing.core">PImage</a>&nbsp;theImg)</pre>
<div class="block">Gets the average color of the pixels inside of a blob (argb)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shape</code> - the arraylist of points defining a shape get the color of.  Same coordinate system as the image.</dd>
<dd><code>theImg</code> - the image to use to get the average color within a shape</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the average color of the blob</dd>
<script type="text/javascript">
<!--
document.getElementsByTagName('html')[0].className = 'isjs';function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }
-->
</script>
<div id="test" class="toggleList example"><dl><dt onclick="toggle(this);"><span>+</span>Example</dt><dd><pre>/*
Opens an image containing blobs and saves the outlines of the blobs 
 to an arraylist made of arraylists of PVectors.  Draws the found outlines in red.
 Gets the average color of each blob and draws it as a rectangle in the upper left corner of the screen
 
 Install the blob detection library (http://www.v3ga.net/processing/BlobDetection/)
 and lee byron's mesh library (http://leebyron.com/mesh/)
 */
import greyshed.lib.*; //import the library
import megamu.mesh.*; //import mesh library
import blobDetection.*; //import blob detection library

PImage img; //this is the image we'll find blobs in
//make an arraylist to store all of our blobs.  Each blob is itself an arraylist of PVectors (the points on the blob)
ArrayList<ArrayList<PVector>> blobMatrix = new ArrayList<ArrayList<PVector>>();
ShapeMethods sm = new ShapeMethods(this);

void setup() {
  size(640, 480); //set our screen size
  img = loadImage("colorStraws.jpg"); //load the picture containing our blobs (or replace with webcam image)
}

void draw() {
  image(img, 0, 0); //draw our image containing blobs to the screen
  //find the blobs in the image using a threshold of .5, and save them to the arraylist "blobMatrix"
  blobMatrix = sm.getBlobs(img, .2); 
  noFill(); //don't fill our drawn shapes
  stroke(255, 0, 255); //set our stroke color to red
  strokeWeight(2); //set our lineweight to 2
  //draw each of our found blobs to the screen
  for (int i = 0; i< blobMatrix.size(); i++) {
    noFill();
    sm.drawPolylineShape(blobMatrix.get(i)); //draw the outline of the blob
    color myColor = sm.getBlobColor(blobMatrix.get(i), img); //get the color of the blob
    fill(myColor); //set the fill of the blob
    rect(30*i, 0, 30, 30); //draw a rectangle in the upper left hand of the screen representing the average color of the blob
  }
}
</pre></dd></dl></div></dl>
</li>
</ul>
<a name="drawPolylineShape-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawPolylineShape</h4>
<pre>public&nbsp;void&nbsp;drawPolylineShape(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;polylineShape)</pre>
<div class="block">Draws an arraylist of PVectors as a polyline using processing's beginShape/vertex/endshape sequence.
<p>
This might be the wrong way of doing this, and you can easily implement this on your own, but it's a quick shorthand method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polylineShape</code> - the arraylist of points defining a polyline to draw</dd>
</dl>
</li>
</ul>
<a name="drawPolylineShape-java.util.ArrayList-boolean-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>drawPolylineShape</h4>
<pre>public&nbsp;void&nbsp;drawPolylineShape(java.util.ArrayList&lt;<a href="http://processing.github.io/processing-javadocs/core/processing/core/PVector.html?is-external=true" title="class or interface in processing.core">PVector</a>&gt;&nbsp;polylineShape,
                              boolean&nbsp;close)</pre>
<div class="block">Draws an arraylist of PVectors as a polyline using processing's beginShape/vertex/endshape sequence.
<p>
Specify "close" boolean to designate if shape should be drawn closed or left open</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polylineShape</code> - the arraylist of points defining a polyline to draw</dd>
<dd><code>close</code> - should the polyline be closed?  True for Closed, False for Open</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../greyshed/lib/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../greyshed/lib/RotatingCalipers.html" title="class in greyshed.lib"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../index.html?greyshed/lib/ShapeMethods.html" target="_top">Frames</a></li>
<li><a href="ShapeMethods.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Processing Library AAS by Ryan Luke Johns. (c) 2016</small></p>
</body>
</html>
